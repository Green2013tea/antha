// /equipment/liquidHandler/liquidHandler.go: Part of the Antha language
// Copyright (C) 2015 The Antha authors. All rights reserved.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
//
// For more information relating to the software or licensing issues please
// contact license@antha-lang.org or write to the Antha team c/o
// Synthace Ltd. The London Bioscience Innovation Centre
// 2 Royal College St, London NW1 0NH UK

// Package liquidHandler defines a liquid handler implementation as an Antha compatible
// equipment.
package liquidHandler

import (
	"encoding/json"
	"errors"
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"github.com/antha-lang/antha/microArch/driver/liquidhandling"
	"github.com/antha-lang/antha/microArch/equipment"
	"github.com/antha-lang/antha/microArch/equipment/action"
	"github.com/antha-lang/antha/microArch/factory"
	schedulerLiquidhandling "github.com/antha-lang/antha/microArch/scheduler/liquidhandling"
	"sync"
)

var (
	notImplemented  = errors.New("not implemented")
	requestNotFound = errors.New("request for block not found")
)

//AnthaLiquidHandler represents a liquidHandler that can be identified as an antha compatible
// device, represented by and ID and that responds to a certain set of Behaviours
type AnthaLiquidHandler struct {
	ID         string
	Behaviours []equipment.Behaviour
	Driver     liquidhandling.ExtendedLiquidhandlingDriver
	properties *liquidhandling.LHProperties
	queue      map[wtype.ThreadID]*schedulerLiquidhandling.LHRequest
	queueLock  sync.Mutex
	completed  map[wtype.ThreadID]*schedulerLiquidhandling.LHRequest
	planner    map[wtype.ThreadID]*schedulerLiquidhandling.Liquidhandler
}

//NewAnthaLiquidHandler instantiates a LiquidHandler identified by id and supporting the following behaviours:
// action.LH_MOVE
// action.LH_MOVE_EXPLICIT
// action.LH_MOVE_RAW
// action.LH_ASPIRATE
// action.LH_DISPENSE
// action.LH_LOAD_TIPS
// action.LH_UNLOAD_TIPS
// action.LH_SET_PIPPETE_SPEED
// action.LH_SET_DRIVE_SPEED
// action.LH_STOP
// action.LH_SET_POSITION_STATE
// action.LH_RESET_PISTONS
// action.LH_WAIT
// action.LH_MIX
func NewAnthaLiquidHandler(id string, d liquidhandling.ExtendedLiquidhandlingDriver) *AnthaLiquidHandler {
	prop, _ := d.GetCapabilities()
	prop.Driver = d

	return &AnthaLiquidHandler{
		ID: id,
		Behaviours: []equipment.Behaviour{
			*equipment.NewBehaviour(action.LH_MIX, ""),
			*equipment.NewBehaviour(action.LH_CONFIG, ""),
			*equipment.NewBehaviour(action.LH_END, ""),
		},
		properties: &prop,
		Driver:     d,
		queue:      make(map[wtype.ThreadID]*schedulerLiquidhandling.LHRequest),
		planner:    make(map[wtype.ThreadID]*schedulerLiquidhandling.Liquidhandler),
		completed:  make(map[wtype.ThreadID]*schedulerLiquidhandling.LHRequest),
	}
}

// Return the resulting request generated by the liquid handler device after
// calling Do(LH_END). Should be called after every Do(LH_END) call otherwise,
// there will be a memory leak.
func (e *AnthaLiquidHandler) TakeRequestOutput(id wtype.BlockID) *schedulerLiquidhandling.LHRequest {
	e.queueLock.Lock()
	defer e.queueLock.Unlock()
	r, ok := e.completed[id.ThreadID]
	if ok {
		delete(e.completed, id.ThreadID)
	}
	return r
}

//GetID returns the unique id for this liquid handler
func (e AnthaLiquidHandler) GetID() string {
	return e.ID
}

//GetEquipmentDefinition returns the equipment definition for the liquid handler.
// This funcionality is still T.B.D. in terms of parameters and returns
func (e AnthaLiquidHandler) GetEquipmentDefinition() {
	//TODO
}

// This funcionality is still T.B.D. in terms of parameters and returns
func (e AnthaLiquidHandler) Do(actionDescription equipment.ActionDescription) error {
	switch actionDescription.Action {
	case action.LH_MIX:
		return e.sendMix(actionDescription)
	case action.LH_END:
		return e.end(actionDescription)
	case action.LH_CONFIG:
		return e.configRequest(actionDescription)
	default:
		return notImplemented
	}
	return nil
}

func (e *AnthaLiquidHandler) configRequest(actionDescription equipment.ActionDescription) error {
	var data struct {
		BlockID wtype.BlockID
	}
	if err := json.Unmarshal([]byte(actionDescription.ActionData), &data); err != nil {
		return err
	}
	var req *schedulerLiquidhandling.LHRequest

	e.queueLock.Lock()
	defer e.queueLock.Unlock()

	if r, ok := e.queue[data.BlockID.ThreadID]; !ok {
		req = schedulerLiquidhandling.NewLHRequest()
		req.BlockID = data.BlockID
		req.Policies = liquidhandling.GetLHPolicyForTest()
		lhplanner := schedulerLiquidhandling.Init(e.properties)

		e.queue[data.BlockID.ThreadID] = req
		e.planner[data.BlockID.ThreadID] = lhplanner
	} else {
		req = r
	}
	//@jmanart TODO this down needs to come from the configuration step, need to figure out the correct cast
	// XXX XXX XXX this can cause big issues
	req.Input_Setup_Weights["MAX_N_PLATES"] = 4.5
	req.Input_Setup_Weights["MAX_N_WELLS"] = 278.0
	req.Input_Setup_Weights["RESIDUAL_VOLUME_WEIGHT"] = 1.0

	// MIS MAJOR TODO XXX XXX XXX here: this HARD CODE needs to be removed or we can only use one type of plate!
	// this stuff needs to come from the database - have to work out user configurability here also
	// oh dear, this code is wronger than I had realised
	// MIS fix here - only allow a single plate in here
	if len(req.Input_platetypes) == 0 {
		pwc := factory.GetPlateByType("pcrplate_with_cooler")
		req.Input_platetypes = append(req.Input_platetypes, pwc)
	}

	return nil
}

func (e *AnthaLiquidHandler) sendMix(actionDescription equipment.ActionDescription) error {
	var sol wtype.LHSolution
	err := json.Unmarshal([]byte(actionDescription.ActionData), &sol)
	if err != nil {
		return err
	}

	e.queueLock.Lock()
	defer e.queueLock.Unlock()

	req, ok := e.queue[sol.BlockID.ThreadID]
	if !ok {
		return requestNotFound
	}
	if sol.Platetype != "" {
		req.Output_platetype = factory.GetPlateByType(sol.Platetype)
	} else {
		req.Output_platetype = factory.GetPlateByType("pcrplate_with_cooler")
	}
	req.Output_solutions[sol.ID] = &sol

	return nil
}

func (e *AnthaLiquidHandler) end(actionDescription equipment.ActionDescription) error {
	blockId := wtype.BlockID{ThreadID: wtype.ThreadID(actionDescription.ActionData)}

	e.queueLock.Lock()
	defer e.queueLock.Unlock()

	req, ok := e.queue[blockId.ThreadID]
	if !ok || req == nil {
		return nil
	}

	planner, ok := e.planner[blockId.ThreadID]
	if !ok {
		return nil
	}

	planner.MakeSolutions(req)

	e.completed[blockId.ThreadID] = req
	e.queue[blockId.ThreadID] = nil
	e.planner[blockId.ThreadID] = nil

	return nil
}

//Status should give a description of the current execution status and any future actions queued to the device
func (e *AnthaLiquidHandler) Status() string {
	//TODO implement properly
	return "OK"
}

//Can queries a piece of equipment about an action execution. The description of the action must meet the constraints
// of the piece of equipment.
func (e *AnthaLiquidHandler) Can(b equipment.ActionDescription) bool {
	for _, eb := range e.Behaviours {
		if eb.Matches(b) {
			return true
		}
	}
	return false
}

//Init driver will be initialized when registered
func (e *AnthaLiquidHandler) Init() error {
	return nil
}

//Shutdown disconnect, turn off, signal whatever is necessary for a graceful shutdown
func (e *AnthaLiquidHandler) Shutdown() error {
	return nil
}
