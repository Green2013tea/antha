// /equipment/liquidHandler/liquidHandler.go: Part of the Antha language
// Copyright (C) 2015 The Antha authors. All rights reserved.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
//
// For more information relating to the software or licensing issues please
// contact license@antha-lang.org or write to the Antha team c/o
// Synthace Ltd. The London Bioscience Innovation Centre
// 2 Royal College St, London NW1 0NH UK

// Package liquidHandler defines a liquid handler implementation as an Antha compatible
// equipment.
package liquidHandler

import (
	"encoding/json"
	"errors"
	"fmt"
	"sync"

	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"github.com/antha-lang/antha/microArch/driver/liquidhandling"
	"github.com/antha-lang/antha/microArch/equipment"
	"github.com/antha-lang/antha/microArch/equipment/action"
	"github.com/antha-lang/antha/microArch/factory"
	"github.com/antha-lang/antha/microArch/logger"
	schedulerLiquidhandling "github.com/antha-lang/antha/microArch/scheduler/liquidhandling"
)

var (
	notImplemented  = errors.New("not implemented")
	requestNotFound = errors.New("request for block not found")
)

//AnthaLiquidHandler represents a liquidHandler that can be identified as an antha compatible
// device, represented by and ID and that responds to a certain set of Behaviours
type AnthaLiquidHandler struct {
	ID         string
	Behaviours []equipment.Behaviour
	Driver     liquidhandling.ExtendedLiquidhandlingDriver
	Properties *liquidhandling.LHProperties
	queue      map[wtype.BlockID]*schedulerLiquidhandling.LHRequest
	queueLock  sync.Mutex
	completed  map[wtype.BlockID]*schedulerLiquidhandling.LHRequest
	planner    map[wtype.BlockID]*schedulerLiquidhandling.Liquidhandler
}

//NewAnthaLiquidHandler instantiates a LiquidHandler identified by id and supporting the following behaviours:
// action.LH_MOVE
// action.LH_MOVE_EXPLICIT
// action.LH_MOVE_RAW
// action.LH_ASPIRATE
// action.LH_DISPENSE
// action.LH_LOAD_TIPS
// action.LH_UNLOAD_TIPS
// action.LH_SET_PIPPETE_SPEED
// action.LH_SET_DRIVE_SPEED
// action.LH_STOP
// action.LH_SET_POSITION_STATE
// action.LH_RESET_PISTONS
// action.LH_WAIT
// action.LH_MIX
func NewAnthaLiquidHandler(id string, d liquidhandling.ExtendedLiquidhandlingDriver) *AnthaLiquidHandler {
	prop, _ := d.GetCapabilities()
	prop.Driver = d

	return &AnthaLiquidHandler{
		ID: id,
		Behaviours: []equipment.Behaviour{
			*equipment.NewBehaviour(action.LH_MIX, ""),
			*equipment.NewBehaviour(action.LH_CONFIG, ""),
			*equipment.NewBehaviour(action.LH_END, ""),
		},
		Properties: &prop,
		Driver:     d,
		queue:      make(map[wtype.BlockID]*schedulerLiquidhandling.LHRequest),
		planner:    make(map[wtype.BlockID]*schedulerLiquidhandling.Liquidhandler),
		completed:  make(map[wtype.BlockID]*schedulerLiquidhandling.LHRequest),
	}
}

// Return the resulting request generated by the liquid handler device after
// calling Do(LH_END). Should be called after every Do(LH_END) call otherwise,
// there will be a memory leak.
func (e *AnthaLiquidHandler) TakeRequestOutput(id wtype.BlockID) *schedulerLiquidhandling.LHRequest {
	e.queueLock.Lock()
	defer e.queueLock.Unlock()
	r, ok := e.completed[id]
	if ok {
		delete(e.completed, id)
	}
	return r
}

//GetID returns the unique id for this liquid handler
func (e AnthaLiquidHandler) GetID() string {
	return e.ID
}

//GetEquipmentDefinition returns the equipment definition for the liquid handler.
// This funcionality is still T.B.D. in terms of parameters and returns
func (e AnthaLiquidHandler) GetEquipmentDefinition() {
	//TODO
}

// This funcionality is still T.B.D. in terms of parameters and returns
func (e AnthaLiquidHandler) Do(actionDescription equipment.ActionDescription) error {
	switch actionDescription.Action {
	case action.LH_MIX:
		return e.sendMix(actionDescription)
	case action.LH_END:
		return e.end(actionDescription)
	case action.LH_CONFIG:
		return e.configRequest(actionDescription)
	default:
		return notImplemented
	}
	return nil
}

func (e *AnthaLiquidHandler) configRequest(actionDescription equipment.ActionDescription) error {
	var data struct {
		BlockID wtype.BlockID
	}

	if err := json.Unmarshal([]byte(actionDescription.ActionData), &data); err != nil {
		return err
	}
	var req *schedulerLiquidhandling.LHRequest

	e.queueLock.Lock()
	defer e.queueLock.Unlock()

	if r, ok := e.queue[data.BlockID]; !ok {
		req = schedulerLiquidhandling.NewLHRequest()
		req.BlockID = data.BlockID
		req.Policies = liquidhandling.GetLHPolicyForTest()
		lhplanner := schedulerLiquidhandling.Init(e.Properties)

		e.queue[data.BlockID] = req
		e.planner[data.BlockID] = lhplanner
	} else {
		req = r
	}

	var params map[string]interface{}
	if err := json.Unmarshal([]byte(actionDescription.ActionData), &params); err != nil {
		return err
	}

	// need to pass the config info into the request

	mnp, ok := params["MAX_N_PLATES"]

	if ok {
		req.Input_setup_weights["MAX_N_PLATES"] = mnp.(float64)
	} else {
		logger.Debug("NO MAX N PLATES FOUND")
	}

	mnw, ok := params["MAX_N_WELLS"]

	if ok {
		req.Input_setup_weights["MAX_N_WELLS"] = mnw.(float64)
	}

	rvw, ok := params["RESIDUAL_VOLUME_WEIGHT"]

	if ok {
		req.Input_setup_weights["RESIDUAL_VOLUME_WEIGHT"] = rvw.(float64)
	}

	pt, ok := params["INPUT_PLATETYPE"]

	if ok {
		for _, v := range pt.([]interface{}) {
			req.Input_platetypes = append(req.Input_platetypes, factory.GetPlateByType(v.(string)))
		}
	}

	opt, ok := params["OUTPUT_PLATETYPE"]

	if ok {
		for _, v := range opt.([]interface{}) {
			req.Output_platetypes = append(req.Output_platetypes, factory.GetPlateByType(v.(string)))
		}
	}

	return nil
}
func (e *AnthaLiquidHandler) sendMix(actionDescription equipment.ActionDescription) error {
	var sol wtype.LHSolution
	err := json.Unmarshal([]byte(actionDescription.ActionData), &sol)
	if err != nil {
		return err
	}

	e.queueLock.Lock()
	defer e.queueLock.Unlock()

	req, ok := e.queue[sol.BlockID]
	if !ok {
		return fmt.Errorf("Request for block id %v not found", sol.BlockID)
	}

	opt := req.Output_platetypes

	if sol.Platetype != "" {
		typ := sol.Platetype
		id := sol.PlateID

		there := findPlateWithType_ID(opt, typ, id)
		if !there {
			plat := factory.GetPlateByType(typ)
			plat.ID = id
			opt = append(opt, plat)
		}
	}

	req.Output_platetypes = opt
	req.Output_solutions[sol.ID] = &sol

	return nil
}

func findPlateWithType_ID(arr []*wtype.LHPlate, typ string, id string) bool {
	there := false
	for _, v := range arr {
		if v.Type == typ {
			if id == "" || id == v.ID {
				there = true
				break
			}
		}
	}
	return there
}

func (e *AnthaLiquidHandler) end(actionDescription equipment.ActionDescription) error {
	blockId := wtype.NewBlockID(actionDescription.ActionData)

	e.queueLock.Lock()
	defer e.queueLock.Unlock()

	req, ok := e.queue[blockId]
	if !ok || req == nil {
		return nil
	}

	planner, ok := e.planner[blockId]
	if !ok {
		return nil
	}

	planner.MakeSolutions(req)

	e.completed[blockId] = req
	e.queue[blockId] = nil
	e.planner[blockId] = nil

	return nil
}

//Status should give a description of the current execution status and any future actions queued to the device
func (e *AnthaLiquidHandler) Status() string {
	//TODO implement properly
	return "OK"
}

//Can queries a piece of equipment about an action execution. The description of the action must meet the constraints
// of the piece of equipment.
func (e *AnthaLiquidHandler) Can(b equipment.ActionDescription) bool {
	for _, eb := range e.Behaviours {
		if eb.Matches(b) {
			return true
		}
	}
	return false
}

//Init driver will be initialized when registered
func (e *AnthaLiquidHandler) Init() error {
	return nil
}

//Shutdown disconnect, turn off, signal whatever is necessary for a graceful shutdown
func (e *AnthaLiquidHandler) Shutdown() error {
	return nil
}
