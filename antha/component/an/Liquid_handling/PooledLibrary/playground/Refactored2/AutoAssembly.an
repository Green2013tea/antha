protocol AutoAssembly

import (
"github.com/antha-lang/antha/antha/anthalib/wtype"
//"github.com/antha-lang/antha/microArch/factory"

)

// Input parameters for this protocol (data)
Parameters (
// PCRprep parameters
Projectname string
Reactiontonames map[string]string
Reactiontopartseqs map[string][]wtype.DNASequence
Reactiontoparttypes map[string][]string
Reactiontoassemblyvolumes map[string][]Volume // e.g. ["left homology arm"]:"templatename"
LHPolicyName string
EnzymeName string
OutputPlateNum int
)

// Data which is returned from this protocol, and data types
Data (
	Error error
)


// Physical Inputs to this protocol with types
Inputs (
MasterMixtype *wtype.LHComponent
Watertype *wtype.LHComponent
Reactiontoparttypes map[string][]*wtype.LHComponent
OutPlate		*wtype.LHPlate
)

// Physical outputs from this protocol with types
Outputs (
Reactions []*wtype.LHComponent
ReactionsMap map[string][]*wtype.LHComponent
)

Requirements {
}

// Conditions to run on startup
Setup {
}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {
	
	// set up a counter to use as an index for increasing well position 
	var counter int
	
	
	// set up some empty slices to fill as we iterate through the reactions
		
	Reactions = make([]*wtype.LHComponent,0)
	ReactionsMap = make(map[string][]*wtype.LHComponent)
	volumes := make([]wunit.Volume,0)
	OutputLocations := make([]string,0)


	// range through the Reaction to template map
	for reactionname, constructname := range Reactiontonames {
	
	// use counter to find next available well position in plate
	wellposition := OutPlate.AllWellPositions(wtype.BYCOLUMN)[counter]
	
	
	// Run TypeIISConstructAssemblyMMX_forscreen element
	result := RunSteps(TypeIISConstructAssemblyMMX_forscreen,
        Parameters{
			InactivationTemp: wunit.NewTemperature(40,"C"),
			InactivationTime: wunit.NewTime(60, "s"),
      		MasterMixVolume: wunit.NewVolume(5, "ul"),
			PartVols: Reactiontoassemblyvolumes[reactionname],
			PartSeqs: Reactiontopartseqs[reactionname],
			OutputReactionName: reactionname,
			OutputConstructName: constructname,
			ReactionTemp: wunit.NewTemperature(25, "C"),
			ReactionTime: wunit.NewTime(1800, "s"),
			ReactionVolume: wunit.NewVolume(20, "ul"),
			OutputLocation: wellposition,
			EnzymeName: EnzymeName,
			LHPolicyName	: LHPolicyName,
     		}, Inputs{
          		MasterMix: MasterMixtype,
				Water: Watertype,
				Parts: Reactiontoparttypes[reactionname],
				OutPlate: OutPlate,
                })

	// add result to reactions slice
    Reactions = append(Reactions, result.Outputs.Reaction)
    ReactionsMap[result.Outputs.Reaction.CName] = result.Outputs.Reaction
	volumes = append(volumes,result.Outputs.Reaction.Volume())
	OutputLocations = append(OutputLocations,wellposition)
	// increase counter by 1 ready for next iteration of loop
	counter++
	
    }
	
	// once all values of loop have been completed, export the plate contents as a csv file
	Error = wtype.ExportPlateCSV(Projectname+".csv", OutPlate,Projectname+"outputPlate", OutputLocations, Reactions, volumes) 
	
}

// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
}