protocol AddPlateReaderresults_2

import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	// "github.com/montanaflynn/stats"
	// "github.com/antha-lang/antha/antha/anthalib/mixer"
	"github.com/antha-lang/antha/microArch/factory"
	"github.com/antha-lang/antha/microArch/driver/liquidhandling"
	// "github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/plot"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/Pubchem"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/buffers"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/Parser"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/doe"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/plot"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/platereader"
	// "path/filepath"
	// antha "github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/AnthaPath"
	 "fmt"
	"strconv"
	"strings"
)


// Input parameters for this protocol (data)
Parameters (

	MarsResultsFileXLSX string //= "250516CCFbubbles/260516ccfbubbles.xlsx" //"lhdoe110216_postspin_postshake.xlsx"
	Sheet               int    //= 0                                        //PRESHAKEPRESPIN
	DesignFile             string //= "250516CCFbubbles/240516DXCFFDoeoutputgilsonright_TEST.xlsx"
	DesignFiletype         string //= "JMP"
	OutputFilename      string //= "250516CCFbubbles/2501516bubblesresults.xlsx"

	Wavelength            int   // = 472
	ReadingTypeinMarsFile string //= "Abs Spectrum"

	Blanks []string //= []string{"P24"}

	FindOptWavelength   bool    // = false
	WellForScanAnalysis []string //= []string{"J5"}

	Responsecolumnstofill []string //= []string{"AbsVLV"}

	ManualComparison      bool  //              = false
	VolumeToManualwells map[string][]string // = map[string][]string{	"AbsVLV": []string{""},}
	Stockvol wunit.Volume //= wunit.NewVolume(20, "ul")

	// of target molecule at wavelength
	Extinctioncoefficient float64 //= 20330
	StockconcinMperL wunit.Concentration //= 0.0002878191305957933
)

// Data which is returned from this protocol, and data types
Data (
	BlankValues []float64
	ResponsetoManualValuesmap map[string][]float64
	MeasuredOptimalWavelength int
	Runs []doe.Run
	R2 float64
	R2Pass bool
	CV float64
	CVpass bool
	Errors []error
)


// Physical Inputs to this protocol with types
Inputs (
	Molecule *wtype.LHComponent
	Diluent *wtype.LHComponent
	PlateType *wtype.LHPlate
)

// Physical outputs from this protocol with types
Outputs (

)

Requirements {
}

// Conditions to run on startup
Setup {
}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {
	
	
	
	var actualconcentrations = make(map[string]wunit.Concentration)
	ResponsetoManualValuesmap = make(map[string][]float64)

	//var volumetovalues = make(map[wunit.Volume][]float64)
	//var testsolstovalues = make(map[string]map[wunit.Volume][]float64)

	molecule, err := pubchem.MakeMolecule(Molecule.CName)
	if err != nil {
		Errorf(err.Error())
	}
	
	Molecularweight := molecule.MolecularWeight
	
	var marsdata parser.MarsData
	

	marsdata, err = parser.ParseMarsXLSXOutput(MarsResultsFileXLSX, Sheet)
	if err != nil {
		Errorf(err.Error())
	}

	// range through pairing up wells from mars output and doe design
	
	var runs []doe.Run
	
	// find out int factors from liquidhandling policies
	policyitemmap := liquidhandling.MakePolicyItems()
	intfactors := make([]string, 0)

	for key, val := range policyitemmap {

		if val.Type.Name() == "int" {
			intfactors = append(intfactors, key)
		}
	}

	if DesignFiletype == "DX" {
		runs, err = doe.RunsFromDXDesign(DesignFile, intfactors)
		if err != nil {
			panic(err)
		}
	} else if DesignFiletype == "JMP" {
		runs, err = doe.RunsFromJMPDesign(DesignFile, []int{}, []int{}, intfactors)
		if err != nil {
			panic(err)
		}
	}
	
	BlankValues = make([]float64,0)
	
	
	for i := range Blanks {
	blankValue, _ := marsdata.ReadingsAsAverage(Blanks[i], 1, Wavelength, ReadingTypeinMarsFile)
	BlankValues = append(BlankValues,blankValue)
	}

	runswithresponses := make([]doe.Run, 0)


	for k, run := range runs {

		// values for r2 to reset each run

		//xvalues := make([]float64, 0)
		//yvalues := make([]float64, 0)

		// add origin
		//xvalues = append(xvalues, 0.0)
		//yvalues = append(yvalues, 0.0)

		for _, response := range Responsecolumnstofill {

			var samples []string
			var manualsamples []string
			var ManualValues = make([]float64,0)
			var manual float64
			var absorbance wtype.Absorbance
			var manualabsorbance wtype.Absorbance
			//var actualconcreplicates = make([]float64, 0)
			var manualCorrectnessFactorValues = make([]float64,0)
			var correctnessFactorValues = make([]float64,0)
		
			// intialise
			Responsecolumntofill := response

			experimentalvolumeinterface, err := runs[k].GetAdditionalInfo("Volume") //  ResponseToVolumeMap[response]
			
			experimentalvolumestr :=  experimentalvolumeinterface.(string)
			
			volandunit := strings.Split(experimentalvolumestr, " ")
			
			vol,err := strconv.ParseFloat(volandunit[0], 64)
			
			experimentalvolume := wunit.NewVolume(vol,volandunit[1])
			
			
			actualconcentrations[experimentalvolume.ToString()] = buffers.DiluteBasedonMolecularWeight(Molecularweight, StockconcinMperL, experimentalvolume, Diluent.CName, wunit.NewVolume(Stockvol.RawValue()-experimentalvolume.RawValue(), "ul"))
	

			//locationHeaders := ResponsetoLocationMap[response]

			//  manual pipetting well
			if ManualComparison {

				manualwell := VolumeToManualwells[experimentalvolumestr][0] // 1st well of array only

				manual, _ = marsdata.ReadingsAsAverage(manualwell, 1, Wavelength, ReadingTypeinMarsFile)

				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" Manual Raw average "+strconv.Itoa(Wavelength), manual)

				manualsamples = VolumeToManualwells[experimentalvolumestr]
				
				for i:= range manualsamples {
				manualvalue, _ := marsdata.ReadingsAsAverage(manualsamples[i], 1, Wavelength, ReadingTypeinMarsFile)
				ManualValues = append(ManualValues,manualvalue)
				}
				
				ResponsetoManualValuesmap[experimentalvolumestr] = ManualValues
				
			}
			

			// then per replicate ...

			//for i, locationheader := range locationHeaders {
				well, err := runs[k].GetAdditionalInfo("Location")
				if err != nil {
					panic(err)
				}

				// check optimal difference for each well

				//Responsecolumntofill = response + "replicate_" + strconv.Itoa(i+1)

				if FindOptWavelength {
					MeasuredOptimalWavelength = marsdata.FindOptimalWavelength(well.(string), Blanks[0], "Raw Data")
					//measuredoptimalwavelengths = append(measuredoptimalwavelengths, meassuredoptwavelength)
					
				}

				
				rawaverage, err := marsdata.ReadingsAsAverage(well.(string), 1, Wavelength, ReadingTypeinMarsFile)

				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" Raw average "+strconv.Itoa(Wavelength), rawaverage)

				// blank correct

				samples = []string{well.(string)}

				blankcorrected, err := marsdata.BlankCorrect(samples, Blanks, Wavelength, ReadingTypeinMarsFile)
				
				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" BlankCorrected "+strconv.Itoa(Wavelength), blankcorrected)

				// path length correct
				pathlength, err := platereader.EstimatePathLength(factory.GetPlateByType("greiner384_riser"), wunit.NewVolume(Stockvol.RawValue()+experimentalvolume.RawValue(), "ul"))

				if err != nil {
					panic(err)
				}
			
				
				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" pathlength "+strconv.Itoa(Wavelength), pathlength.ToString())

				absorbance.Reading = blankcorrected

				pathlengthcorrect := platereader.PathlengthCorrect(pathlength, absorbance)
				
				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" Pathlength corrected "+strconv.Itoa(Wavelength), pathlengthcorrect.Reading)

				// molar absorbtivity of tartazine at 472nm is 20330
				// http://www.biochrom.co.uk/faq/8/119/what-is-the-limit-of-detection-of-the-zenyth-200.html

				actualconc := platereader.Concentration(pathlengthcorrect, Extinctioncoefficient)

				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+"ActualConc", actualconc.SIValue())

				// calculate correctness factor based on expected conc

				expectedconc := actualconcentrations[experimentalvolume.ToString()]
				correctnessfactor := actualconc.SIValue() / expectedconc.SIValue()

				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" ExpectedConc "+strconv.Itoa(Wavelength), expectedconc.SIValue())
				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" CorrectnessFactor "+strconv.Itoa(Wavelength), correctnessfactor)
				correctnessFactorValues = append(correctnessFactorValues,correctnessfactor)
				

				//xvalues = append(xvalues, expectedconc.SIValue())
				//yvalues = append(yvalues, actualconc.SIValue())
				//actualconcreplicates = append(actualconcreplicates, actualconc.SIValue())
			
				// add comparison to manually pipetted wells
				if ManualComparison {
					manualblankcorrected, _ := marsdata.BlankCorrect(manualsamples, Blanks, Wavelength, ReadingTypeinMarsFile)
					manualabsorbance.Reading = manualblankcorrected
					manualpathlengthcorrect := platereader.PathlengthCorrect(pathlength, manualabsorbance)
					manualactualconc := platereader.Concentration(manualpathlengthcorrect, Extinctioncoefficient)
					run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+"ManualActualConc", manualactualconc.SIValue())
					manualcorrectnessfactor := actualconc.SIValue() / manualactualconc.SIValue()
					manualCorrectnessFactorValues = append(manualCorrectnessFactorValues,manualcorrectnessfactor)
					run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" ManualCorrectnessFactor "+strconv.Itoa(Wavelength), manualcorrectnessfactor)
				}

			

			// process replicates into mean and cv
			//mean := stats.Mean(actualconcreplicates)
			//stdev := stats.StdDevS(actualconcreplicates)

			//cv := stdev / mean

			//run = doe.AddNewResponseFieldandValue(run, response+"_Average_ActualConc", mean)
			//run = doe.AddNewResponseFieldandValue(run, response+"_CV_ActualConc", cv)
			
			
			// average of correctness factor values
			//meanCF := stats.Mean(correctnessFactorValues)
			//run = doe.AddNewResponseFieldandValue(run, response+"_Average_CorrectnessFactor", meanCF)
			
		/*	if ManualComparison {
			
			meanManCF := stats.Mean(manualCorrectnessFactorValues)
			run = doe.AddNewResponseFieldandValue(run, response+"_Average_ManualCorrectnessFactor", meanManCF)
			}
		*/
		
		}

		//rsquared := plot.Rsquared("Expected Conc", xvalues, "Actual Conc", yvalues)
		//run.AddResponseValue("R2", rsquared)

		//xygraph := plot.Plot(xvalues, [][]float64{yvalues})
		//filenameandextension := strings.Split(OutputFilename, ".")
		//plot.Export(xygraph, filenameandextension[0]+".png")

		runswithresponses = append(runswithresponses, run)
	}
	
	doe.XLSXFileFromRuns(runswithresponses,OutputFilename,DesignFiletype)
	
	Runs = runswithresponses

}

// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
	
	Errors = make([]error,0)
	
		xvalues := make([]float64, 0)
		yvalues := make([]float64, 0)

		// add origin
		xvalues = append(xvalues, 0.0)
		yvalues = append(yvalues, 0.0)
	
	fmt.Println("in analysis")
	
	if len(Runs)==0{
		Errorf("no runs")
	}
	// now calculate mean, CV, r2 and plot results
	for i,runwithresponses := range Runs {
		// values for r2 to reset each run

	// get response value and check if it's a float64 type
	expectedconc, err := runwithresponses.GetResponseValue(" ExpectedConc "+strconv.Itoa(Wavelength))
	
	if err != nil{
		Errors = append(Errors,err)
	}
	
	expectedconcfloat,floattrue := expectedconc.(float64)
	// if float64 is true 
	if floattrue {
		xvalues = append(xvalues, expectedconcfloat)
	}else {
		Errorf("Run"+fmt.Sprint(i,runwithresponses)+" ExpectedConc:"+fmt.Sprint(expectedconcfloat))
	}

	// get response value and check if it's a float64 type
	actualconc, err := runwithresponses.GetResponseValue("AbsorbanceActualConc")
	
	if err != nil{
		fmt.Println(err.Error())
		Errors = append(Errors,err)
	}
	
	actualconcfloat,floattrue := actualconc.(float64)
	
	if floattrue {
		yvalues = append(yvalues,actualconcfloat )
	}else {
		fmt.Println(err.Error())
		Errorf(" ActualConc:"+fmt.Sprint(actualconcfloat))
	}
		
	}
		
		
	R2 = plot.Rsquared("Expected Conc", xvalues, "Actual Conc", yvalues)
	//run.AddResponseValue("R2", rsquared)

	xygraph := plot.Plot(xvalues, [][]float64{yvalues})
	filenameandextension := strings.Split(OutputFilename, ".")
	plot.Export(xygraph, filenameandextension[0]+".png")
}


// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
}
