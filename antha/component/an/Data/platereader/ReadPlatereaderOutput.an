protocol AddPlateReaderresults

import (
	//"github.com/antha-lang/antha/antha/anthalib/wtype"
	//"github.com/antha-lang/antha/antha/anthalib/wutil"
	//"github.com/antha-lang/antha/antha/anthalib/mixer"
	//"github.com/antha-lang/antha/microArch/driver/liquidhandling"
	//"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/image"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/Parser"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/doe"
	//"path/filepath"
	//antha "github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/AnthaPath"
	"fmt"
	//"strconv"
)


// Input parameters for this protocol (data)
Parameters (
	MarsResultsFileXLSX           string 
	DOEFilewithwelllocationsadded string 
	DOEFiletype                   string 
	
	Responsecolumntofill string //= "AbsMV"

	//Wavelength            int    = 440
	ReadingTypeinMarsFile string // = "Abs Spectrum"

	Blanks []string //= []string{"P9"}

	ManualControls []string //= []string{"P24"}
	
)

// Data which is returned from this protocol, and data types
Data (
	OutputFilename string
)


// Physical Inputs to this protocol with types
Inputs (
	
)

// Physical outputs from this protocol with types
Outputs (

)

Requirements {
}

// Conditions to run on startup
Setup {
}

// The core process for this protocol, with the steps to be performed
// for every input





Steps {
	
	var marsdata parser.MarsData
	var err error

	if DOEFiletype == "DX" || DOEFiletype == "Design Expert" {

		marsdata, err = parser.ParseMarsXLSXOutput(MarsResultsFileXLSX)
		if err != nil {
			panic(err)
		}

	}

	runs, err := doe.RunsFromDXDesign(DOEFilewithwelllocationsadded, []string{"Pre_MIX", "POST_MIX"})

	// find optimal wavlength from scan of positive control and blank
	optimalwavelength := marsdata.FindOptimalWavelength(ManualControls[0], Blanks[0], "Raw Data")

	// range through pairing up wells from mars output and doe design

	measuredoptimalwavelengths := make([]int, 0)

	//for i, additional := range AdditionalFactors {
	for _, run := range runs {

		well, err := run.GetAdditionalInfo("Well ID")
		if err != nil {
			panic(err)
		}

		//if run.CheckAdditionalInfo(additional, AdditionalValues[i]) && additional == Additionalfactortoresponsepair[0] {
		/*
			average, err := marsdata.AbsorbanceReading(well.(string), Wavelength, ReadingTypeinMarsFile)
			if err != nil {
				panic(err)
			}
		*/
		// check optimal difference for each well
		meassuredoptwavelength := marsdata.FindOptimalWavelength(well.(string), Blanks[0], "Raw Data")
		measuredoptimalwavelengths = append(measuredoptimalwavelengths, meassuredoptwavelength)
		// blank correct

		samples := []string{well.(string)}

		blankcorrected, err := marsdata.BlankCorrect(samples, Blanks, optimalwavelength, ReadingTypeinMarsFile)
		run.AddResponseValue(Responsecolumntofill, blankcorrected)
		//	}
	}
	//	}

	//runs, err := doe.RunsFromDXDesign(xlsxwithresultsadded string, []string{"Pre_MIX", "POST_MIX"})

	_ = doe.DXXLSXFilefromRuns(runs, OutputFilename)
	//OutputFilename = doe.XLfileFromRuns(runs)

	fmt.Println("Optimal wavelength from manual", optimalwavelength)
	fmt.Println("Optimal wavelength of each sample", measuredoptimalwavelengths)
	
	
	
}

// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
}
